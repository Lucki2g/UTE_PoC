# IGNORE THIS FILE

# Base
You must build a .NET 10 C# minimal API. The purpose of the api is to act as a test engine. The API must be protected via a simple API key.
It should use modern methods and pattern like Dependency Injection.
The folder structure should be services (logic), models (dtos and requests) and controllers (endpoint definitions).
The API will talk to code app written for the Power Platform. The code app is a lowcode test engine where lowcode developers can define tests that will be compiled via DSL to C# unit tests and run in the engine next to procode unittests in the XrmMockup framework.

# Main parts
The testengine API consists of 4 main controllers/areas.

## Git Controller
The git controller is the main controller that controls what branch the lowcode unittests are pushed to. The codebase is the shared codebase between pro developers and lowcode developers. Hence it is important to have control of branches, commits, pull requests etc.
The controller has the following endpoints:
### /load which takes a <branch name>
load loads a branch as the current branch.
### /submit with <target branch name> and body with data
submit creates a pull request to the target branch
### /publish
pushed to the current branch
### /save
save commits some code to the current branch
### /new
new fetches and pulls changes from the main branch, then creates a new branch from default main branch with a name.

## Metadata Controller
The metadata logic controls the current early bound types and metadata generated by XrmContext.
Metadata may change as you are making your tests to new fields.
The controller has the following endpoints:
### /sync
sync will run XrmContext and its Metadata Generator against a dataverse environment to produce the updated early bound types for dataverse tables and metadata of the security roles etc. It also uses https://github.com/thygesteffensen/PAMU_CDS with XrmMockup to work with Power Automate flows. XrmContext, XrmMockup etc. should already be setup in the consumer repo.

## Test Controller
The Test Controller will act as the communication for running and retrieving testcases.
### /run <test>
Runs the given testcase and returns the run result with trace.
### /run all
Runs all unit tests and returns the results.
### / (get)
Returns all metadata for testcases for visual display in frontend app.
### / (put)
Create a new testcase class on the branch. Initializes a new C# class that extends the TestBase class. The general format is:

### / (post)
Update an existing testcase
### / (delete)
Delete a C# testcase from the branch.

## Data Producer Controller
The producer controller contain the testdata initialization and builders to make data for arrange step in AAA pattern.
### / (get)
Get the list of existing producers for display in the frontend.
### / (post)
Update an existing producer
### / (put)
Create a new producer. Intitializes a new partial class for a dataproducer.
There exists a DataProducer per entity, and they act as the "minimal" initialization of an object. For Dataverse it is the entity with the required field sat.
Format:
Filename: DataProducer.<EntityName>.
```
internal partial class DataProducer
{
    internal partial class DataProducer
    {
        internal IOrganizationService Service { get; }
        internal DataProducer(IOrganizationService service) => Service = service;

        internal Draft<Account> DraftValidAccount(Account account = null)
        {
            account ??= new Account();

            // Required + "minimum for our org" defaults
            account.EnsureValue(e => e.CustomerTypeCode, Account_CustomerTypeCode.Customer);
            account.EnsureValue(e => e.AccountNumber, ProduceValidCVR());
            account.EnsureValue(e => e.Name, "Per Aarsleff A/S - C");

            return new Draft<Account>(this, account);
        }
    }
}
```

## Data Extensions Controller
The extensions controller contains the extensions methods also in partial classes per entity type T for the Draft<T> class created by the producers. This controller controls these, that look like:
Filename: DataExtensions.<EntityName>.
```
internal static partial class DataExtensions
{
    internal static Draft<Account> AsDebtor(this Draft<Account> account)
    {
        return account.With(a => a = Account_CustomerTypeCode.Debtor);;
    }
}
```
Endpoints are:
### / (put)
Intialize a new C# partial class in the correct format for the entity type.
### / (post)
Update existing C# class.
### / (get)
Get the existing extensions for display in frontend.
### / (delete)
Remove a C# file contain the provided extensions.

